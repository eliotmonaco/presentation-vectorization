{"title":"Vectorization and iteration in R","markdown":{"yaml":{"title":"Vectorization and iteration in R","author":"Eliot Monaco","date":"4/8/2024","format":{"revealjs":{"theme":"dark","highlight-style":"github","css":"styles.css","width":1300,"slide-number":true,"incremental":true,"code-overflow":"wrap","preview-links":true,"scrollable":true,"chalkboard":{"buttons":false}}}},"headingText":"Vectorization and iteration","containsRefs":false,"markdown":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(\n  echo = TRUE,\n  R.options = list(width = 120)\n)\n```\n\n```{r include=FALSE}\nsource(\"fn.R\")\n```\n\n\nWhat does it mean?\n\n- Iteration: performing the same operation/function(s) multiple times\n- Vectorization: function input is a vector, function output is a vector\n\n## Outline\n\n- Vector basics\n- Methods to vectorize your code\n    + loops, `dplyr::mutate()`, `apply()` & friends, `purrr::map()` & friends\n- Useful workflows for introducing vectorization\n\n# Vector basics\n\n## What is a vector?\n\n- A data structure (container) with one dimension\n- Property = length\n- Types\n    + Atomic vector (one data type)\n    + List (multiple data types)\n\n## Vector types\n\n::::: {#row1}\n:::: {.columns}\n::: {.column .nonincremental width=\"50%\"}\n\nAtomic vector\n\n* elements are the same data type\n\n:::\n::: {.column width=\"50%\"}\n\n![numeric vector](images/numeric-vector.png)\n\n![character vector](images/character-vector.png)\n\n:::\n::::\n:::::\n\n::::: {#row2}\n:::: {.columns}\n::: {.column .nonincremental width=\"50%\"}\n\nList\n\n* elements can be different data types and data structures\n\n:::\n::: {.column width=\"50%\"}\n\n![](images/list.png)\n\n:::\n::::\n:::::\n\n## Atomic vectors\n\n`c()` creates atomic vectors.\n\n```{r}\nx <- c(\"a\", \"b\", \"c\", \"apple\", \"banana\", \"coconut\")    # character vector\ny <- c(10, 100, 1000, 10000, 100000)                   # numeric vector\nz <- c(TRUE, TRUE, FALSE, FALSE)                       # logical vector\n```\n\n```{r}\nclass(x)\nclass(y)\nclass(z)\n```\n\n## Lists\n\n`list()` creates lists.\n\n```{r}\nx <- c(\"a\", \"b\", \"c\", \"apple\", \"banana\", \"coconut\")    # character vector\ny <- c(10, 100, 1000, 10000, 100000)                   # numeric vector\nz <- c(TRUE, TRUE, FALSE, FALSE)                       # logical vector\n\nmy_list <- list(\n  element1 = x,\n  element2 = y,\n  element3 = z\n)\n```\n\n```{r}\nstr(my_list)\n```\n\n## Um actually\n\n*Technically...*\n\n:::{.nonincremental}\n* \"vector\" includes both atomic vectors and lists\n* dataframe columns are atomic vectors\n:::\n\n. . .\n\n*But colloquially...*\n\n:::{.nonincremental}\n* \"vector\" means an atomic vector\n* \"list\" means a list\n:::\n\n# Indexing: How to access elements of vectors\n\n## Indexing vectors\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\n. . .\n\nUse square brackets `[]` to access specific elements of atomic vectors by their numeric position.\n\n. . .\n\n```{r}\nelements[3]\n```\n\n. . .\n\n```{r}\nelements[1:3]\n```\n\n## Assign & subtract\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\n. . .\n\nAssignment by indexing\n\n```{r}\nelements[5] <- \"cheese\"\n\nelements\n```\n\n. . .\n\nSubtraction by indexing\n\n```{r}\nelements <- elements[-5]\n\nelements\n```\n\n## Numeric vs logical indexing\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\nVectors are indexed with other vectors.\n\n. . .\n\n```{r}\nelements[c(1, 4)]               # numeric vector\n```\n\n. . .\n\n```{r}\nelements[c(T, F, F, T)]         # logical vector\n```\n\n## Numeric vs logical indexing\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\nIf the indexing vector isn't the same length as the vector being indexed, the indexing vector will be recycled.\n\n. . .\n\n```{r}\nelements[c(T, F)]\n```\n\n```{r}\nelements[c(T, F, F)]\n```\n\n## Index with expressions\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\nIf the value of an expression is a numeric or logical vector, it can be used to index.\n\n. . .\n\n```{r}\n2 + 2                  # numeric expression\nelements[2 + 2]\n```\n\n## Index with expressions\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\nIf the value of an expression is a numeric or logical vector, it can be used to index.\n\n```{r}\nstringr::str_detect(elements, \"^e|e$\")                  # logical expression\nelements[stringr::str_detect(elements, \"^e|e$\")]\n```\n\n## Indexing lists\n\n:::: {.columns}\n::: {.column}\n\nSingle square brackets `[]`\n\n```{r}\nmy_list[1]\nclass(my_list[1])\n```\n\n:::\n::: {.column}\n\nDouble square brackets `[[]]`\n\n```{r}\nmy_list[[1]]\nclass(my_list[[1]])\n```\n\n:::\n::::\n\n## Indexing lists\n\nAccess list elements by name using `$` (equivalent to `[[]]`).\n\n:::: {.columns}\n::: {.column}\n\n```{r}\nmy_list$element1\nclass(my_list$element1)\n```\n\n:::\n::: {.column}\n\n```{r}\nmy_list[[\"element1\"]]\nclass(my_list[[\"element1\"]])\n```\n\n:::\n::::\n\n# Methods: Using vectorization and iteration in your code\n\n## Methods\n\n::: {.nonincremental}\n- Loops\n- `dplyr::mutate()`\n- `apply()` & friends\n- `purrr::map()` & friends\n:::\n\n## Loops\n\n::: {.nonincremental}\n- for & while\n- extremely useful and versatile\n- covered in a prior RUG workshop\n- loops will return when we talk about workflow\n:::\n\n## `dplyr::mutate()`\n\n::: {.nonincremental}\n- iterate over all rows of a dataframe by apply a function to a column or columns\n- create new columns or modify existing columns\n:::\n\n[`mutate()` documentation](https://dplyr.tidyverse.org/reference/mutate.html#ref-usage){preview-link=\"true\"}\n\n## Syntax\n\n```{r eval=FALSE}\ndata <- data |>\n  mutate(column_name = some_function(existing_column))      # dummy syntax\n```\n\n## `mutate()`: create a new column\n\nCalculate age from two dates.\n\n```{r}\nlibrary(tidyverse)\nlibrary(ksTracking)\n\ndate1 <- as.Date(\"1980-08-01\")\ndate2 <- as.Date(Sys.Date())\n\ncalculate_age(date1, date2)         # the function by itself\n```\n\n## `mutate()`: create a new column\n\n::: {.panel-tabset}\n\n### Dataframe\n\nSimulate a data set with two date variables: `birth_date` and `collection_date`.\n\n```{r}\nbl_data <- sim_bl_data(n_tested = 10, test_range = c(\"2024-01-01\", \"2024-03-31\"))\n```\n\n```{r}\n#| code-fold: true\n\nbl_data |>\n  my_gt() |>\n  gtExtras::gt_highlight_cols(\n    columns = c(birth_date, collection_date),\n    fill = \"thistle2\"\n  )\n```\n\n### `mutate()`\n\n```{r eval=FALSE}\ndata <- data |>\n  mutate(column_name = some_function(existing_column))      # dummy syntax\n```\n\n```{r}\nbl_data2 <- bl_data |>\n  mutate(                                                   # for real\n    age = calculate_age(birth_date, collection_date),\n    .after = collection_date\n  )\n```\n\n```{r}\n#| code-fold: true\n\nbl_data2 |>\n  my_gt() |>\n  gtExtras::gt_highlight_cols(\n    columns = c(birth_date, collection_date),\n    fill = \"thistle2\"\n  ) |>\n  gtExtras::gt_highlight_cols(\n    columns = c(age),\n    fill = \"palegreen\"\n  )\n```\n\n:::\n\n## `mutate()` + `across()`\n\n`across()` applies the `mutate()` call to multiple columns at once.\n\n::: {.panel-tabset}\n\n### Select columns\n\n```{r}\nbl_data |>\n  select(starts_with(\"coll_add\")) |>      # tidy selection\n  my_gt()\n```\n\n### `mutate()`\n\n```{r}\nbl_data3 <- bl_data |>\n  mutate(across(starts_with(\"coll_add\"), toupper))   # convert to uppercase\n```\n\n```{r}\n#| code-fold: true\n\nbl_data3 |>\n  select(starts_with(\"coll_add\")) |>\n  my_gt()\n```\n\n:::\n\n## `apply()` & friends\n\n::: {.nonincremental}\n- `apply()`: modify rows or columns of a dataframe\n- `lapply()`: modify a vector or list\n- also `sapply()`, `vapply()`, & `mapply()`\n:::\n\n## `lapply()`\n\nIterate over a vector or list\n\n::: {.nonincremental}\n- Input: a vector or list\n- Output: a vector or list\n- Arguments:\n    + `X`: a vector or list\n    + `FUN`: a function\n    + `...`: additional arguments to `FUN` (optional)\n:::\n\n## `lapply()`\n\n::: {.panel-tabset}\n\n### List\n\n```{r}\nl <- list()\n\nfor (i in 1:5) {                             # populate a list\n  l[[i]] <- c(                               # each element contains:\n    sample(colors(), 1),                     #  - a color\n    sample(rownames(alr4::brains), 1),       #  - an animal\n    sample(rownames(alr4::BigMac2003), 1)    #  - a city\n  )\n}\n\nl\n```\n\n### `lapply()`\n\n```{r}\nl2 <- lapply(\n  X = l,               # list input\n  FUN = paste,         # function: `paste()`\n  collapse = \"; \"      # additional argument to `paste()`\n)\n\nl2\n```\n\n:::\n\n## `lapply()` + custom function\n\n::: {.panel-tabset}\n\n### List\n\n```{r}\nl <- list(                  # create a list of 3 dataframes\n  df1 = mtcars,\n  df2 = dplyr::starwars,\n  df3 = bl_data\n)\n```\n\n```{r results='asis'}\n#| code-fold: true\n\nfor (i in 1:length(l)) {    # print a section of each table\n  l[[i]][1:3, 1:11] |>\n    my_gt() |>\n    print()\n}\n```\n\n### Function\n\n```{r}\n# custom function to\n#   1) modify column names \n#   2) add a column\n\nfn <- function(df) {\n  colnames(df) <- stringr::str_to_title(colnames(df))\n  df |>\n    mutate(Action = NA, .before = everything())\n}\n```\n\n### `lapply()`\n\n```{r}\nl2 <- lapply(\n  X = l,               # list input\n  FUN = fn             # function: `fn()`\n)\n```\n\n```{r results='asis'}\n#| code-fold: true\n\nfor (i in 1:length(l2)) {    # print a section of each table\n  l2[[i]][1:3, 1:12] |>\n    my_gt() |>\n    print()\n}\n```\n\n:::\n\n## `apply()`\n\nIterate over a dataframe's rows, columns, or both\n\n::: {.nonincremental}\n- Input: a dataframe\n- Output: a vector or list\n- Arguments:\n    + `X`: a dataframe\n    + `MARGIN`: `1` for rows, `2` for columns (`c(1, 2)` for both)\n    + `FUN`: a function\n    + `...`: additional arguments to `FUN` (optional)\n:::\n\n## `apply()`\n\n::: {.panel-tabset}\n\n### Dataframe\n\n```{r}\n#| output-location: column\n\n# create a dataframe from a list\n\nl <- list()\n\nfor (i in 1:5) {\n  l[[i]] <- sample(1:100, 10, T)\n}\n\ndf <- as_tibble(do.call(cbind, l))\n\ndf\n```\n\n### Rows\n\n```{r}\nrow_sums <- apply(\n  X = df,               # dataframe input\n  MARGIN = 1,           # apply over rows\n  FUN = sum             # function: `sum()`\n)\n\nrow_sums\n```\n\n### Columns\n\n```{r}\ncol_sums <- apply(\n  X = df,               # dataframe input\n  MARGIN = 2,           # apply over columns\n  FUN = sum             # function: `sum()`\n)\n\ncol_sums\n```\n\n:::\n\n## `apply()` vs `mutate()`\n\n::: {.nonincremental}\n- `mutate()`: applies a function to each row separately\n- `apply()`: applies a function to each row or each column as a whole\n:::\n\n## `apply()` + custom function\n\n::: {.panel-tabset}\n\n### Original fn\n\nCheck if a sequence of dates is in chronological order.\n\n```{r}\ncheck_date_seq            # from ksTracking package\n```\n\n### fn within the fn\n\n```{r}\nfn <- function(dates) {\n  # Convert a vector of dates to the underlying numeric values, removing NAs\n  seq <- stats::na.omit(as.numeric(as.Date(dates)))\n\n  # Compare the current order of `seq` to the sorted order (small to large)\n  all(seq == sort(seq))\n}\n```\n\n### Example\n\n```{r}\ndates1 <- c(\"1800-01-01\", \"1900-01-01\", \"2000-01-01\")   # in chronological order\n\nfn(dates1)\n\ndates2 <- c(\"2000-01-01\", \"1900-01-01\", \"1800-01-01\")   # not in chronological order\n\nfn(dates2)\n```\n\n:::\n\n## `apply()` + custom function\n\n::: {.panel-tabset}\n\n### Dataframe\n\n```{r}\n#| output-location: column\n\ndf <- tibble(\n  birth_date = sample(\n    seq.Date(\n      from = as.Date(\"1930-01-01\"),\n      to = as.Date(\"2020-12-31\"),\n      by = \"day\"\n    ),\n    size = 10,\n    replace = T\n  ),\n  test_date1 = sample(\n    seq.Date(\n      from = as.Date(\"2022-01-01\"),\n      to = as.Date(\"2023-12-21\"),\n      by = \"day\"\n    ),\n    size = 10,\n    replace = T\n  ),\n  test_date2 = sample(\n    seq.Date(\n      from = as.Date(\"2022-01-01\"),\n      to = as.Date(\"2023-12-21\"),\n      by = \"day\"\n    ),\n    size = 10,\n    replace = T\n  ),\n  city = sample(\n    ks_city_zip$city,\n    size = 10,\n    replace = T\n  ),\n  state = \"KS\"\n)\n\ndf |> my_gt()\n```\n\n### `apply()`\n\n```{r}\ndf$correct_date_seq <- apply(\n  X = df[, 1:3],                   # note partial dataframe input\n  MARGIN = 1,                      # apply over rows\n  FUN = fn                         # function: `fn()'\n)\n\ndf |> my_gt()\n```\n\n### Bonus\n\nPackage the date function and `apply()` together\n\n```{r}\nfn2 <- function(...) {      # `fn2()` is vectorized: it takes vectors as args,\n  df <- cbind(...)          # and outputs a vector of the same length\n\n  fn1 <- function(dates) {\n    seq <- stats::na.omit(as.numeric(as.Date(dates)))\n    all(seq == sort(seq))\n  }\n\n  apply(df, 1, fn)\n}\n\ndf$correct_date_seq2 <- fn2(df$birth_date, df$test_date1, df$test_date2)\n\ndf |> my_gt()\n```\n\n:::\n\n## `purrr::map()`\n\n:::::: {.panel-tabset}\n\n### Specs\n\n::::: {.columns}\n:::: {.column .nonincremental width=\"50%\"}\n::: {.nonincremental}\n\n`lapply()`\n\n- Input: a vector or list\n- Output: a vector or list\n- Arguments:\n    + `X`: a vector or list\n    + `FUN`: a function\n    + `...`: additional arguments to `FUN` (optional)\n\n:::\n::::\n\n:::: {.column .nonincremental width=\"50%\"}\n::: {.nonincremental}\n\n`map()`\n\n- Input: a vector or list\n- Output: a vector or list\n- Arguments:\n    + `.x`: a vector or list\n    + `.f`: a function\n    + `...`: additional arguments to `.f` (optional)\n\n:::\n::::\n:::::\n\n### List\n\n```{r}\nl <- list()\n\nfor (i in 1:5) {                             # populate a list\n  l[[i]] <- c(                               # each element contains:\n    sample(colors(), 1),                     #  - a color\n    sample(rownames(alr4::brains), 1),       #  - an animal\n    sample(rownames(alr4::BigMac2003), 1)    #  - a city\n  )\n}\n\nl\n```\n\n### Compare use\n\n::::: {.columns}\n:::: {.column .nonincremental width=\"50%\"}\n\n```{r}\nl2 <- lapply(\n  X = l,\n  FUN = paste,\n  collapse = \"; \"\n)\n\nl2\n```\n\n::::\n:::: {.column .nonincremental width=\"50%\"}\n\n```{r}\nl3 <- map(\n  .x = l,\n  .f = paste,\n  collapse = \"; \"\n)\n\nl3\n```\n\n::::\n:::::\n::::::\n\n## `map()` & friends\n\n\n\n\n```{r}\n\n```\n\n\n\n\n\n\n\n\n<!-- ## `lapply()` basics -->\n\n<!-- Input: a vector or list. Output: a vector or list. -->\n\n<!-- ::: {.sublist .nonincremental} -->\n<!-- `lapply()` arguments: -->\n\n<!-- - `X`: a vector or list -->\n<!-- - `FUN`: a function -->\n<!-- - `...`: additional (optional) arguments to `FUN` -->\n<!-- ::: -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- ***Example:*** Convert a nested list to a dataframe. -->\n\n<!-- Create a nested list. -->\n\n<!-- ```{r} -->\n<!-- name <- c(\"Katara\", \"Aang\", \"Sokka\", \"Toph\", \"Zuko\") -->\n<!-- home <- c( -->\n<!--   \"Southern Water Tribe\", \"Southern Air Temple\", -->\n<!--   \"Southern Water Tribe\", \"Earth Kingdom\", \"Fire Nation\" -->\n<!-- ) -->\n<!-- age <- c(14, 112, 15, 12, 16) -->\n<!-- element <- c(\"water\", \"air\", NA, \"earth\", \"fire\") -->\n\n<!-- avatar_list <- list() -->\n\n<!-- for (i in 1:length(name)) { -->\n<!--   avatar_list[[i]] <- list( -->\n<!--     name = name[i], home = home[i], age = age[i], element = element[i] -->\n<!--   ) -->\n<!-- } -->\n<!-- ``` -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- ***Example:*** Convert a nested list to a dataframe. -->\n\n<!-- ```{r} -->\n<!-- str(avatar_list) -->\n<!-- ``` -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- ***Example:*** Convert a nested list to a dataframe. -->\n\n<!-- Use `lapply()` to call `as_tibble()`, turning each list element into a one-row dataframe. -->\n\n<!-- ```{r} -->\n<!-- avatar_list2 <- lapply(X = avatar_list, FUN = as_tibble) -->\n<!-- ``` -->\n\n<!-- . . . -->\n\n<!-- :::: {.columns} -->\n<!-- ::: {.column width=\"50%\"} -->\n<!-- ```{r} -->\n<!-- # Input -->\n<!-- str(avatar_list) -->\n<!-- ``` -->\n<!-- ::: -->\n<!-- ::: {.column width=\"50%\"} -->\n<!-- ```{r} -->\n<!-- # Output -->\n<!-- str(avatar_list2) -->\n<!-- ``` -->\n<!-- ::: -->\n<!-- :::: -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- ***Example:*** Convert a nested list to a dataframe. -->\n\n<!-- The new list can now be converted to a dataframe using `purrr::list_rbind()`. -->\n\n<!-- ```{r} -->\n<!-- avatar_df <- list_rbind(avatar_list2) -->\n<!-- ``` -->\n<!-- . . . -->\n<!-- ```{r} -->\n<!-- head(avatar_df) %>% gfx_kable() -->\n<!-- ``` -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- ***Example:*** Convert a nested list to a dataframe. -->\n\n<!-- The whole thing: -->\n\n<!-- ```{r} -->\n<!-- avatar_list2 <- lapply(X = avatar_list, FUN = as_tibble) -->\n\n<!-- avatar_df <- list_rbind(avatar_list2) -->\n<!-- ``` -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- Using `...` to pass additional arguments to `FUN`: -->\n\n<!-- ```{r} -->\n<!-- avatar_list2 <- lapply( -->\n<!--   X = avatar_list, FUN = as_tibble, -->\n<!--   .name_repair = function(x) paste0(x, \"_season_1\")    # New argument, modifies column names -->\n<!-- ) -->\n\n<!-- avatar_df <- list_rbind(avatar_list2) -->\n<!-- ``` -->\n<!-- . . . -->\n<!-- ```{r} -->\n<!-- head(avatar_df) %>% gfx_kable() -->\n<!-- ``` -->\n\n<!-- ## `map()` -->\n\n<!-- `map()` (purrr) is essentially the same as `lapply()`. -->\n\n<!-- ```{r} -->\n<!-- avatar_list2 <- lapply(X = avatar_list, FUN = as_tibble) -->\n\n<!-- avatar_list3 <- map(.x = avatar_list, .f = as_tibble) -->\n\n<!-- all.equal(avatar_list2, avatar_list3) -->\n<!-- ``` -->\n\n<!-- . . . -->\n\n<!-- ::: {.sublist} -->\n<!-- Variations for different types of input and output, for example: -->\n\n<!-- - `map2()`: two inputs (`.x` & `.y`), e.g., two vectors or lists of the same length -->\n<!-- - `pmap()`: input is a list (`.l`), each element of which is a vector passed as an argument to `.f` -->\n<!-- ::: -->\n\n<!-- ## `map2()`: two lists as input, list output {.scrollable} -->\n\n<!-- ***Example:*** Subset each dataframe in a list. -->\n\n<!-- ```{r} -->\n<!-- # A list of dataframes with characters and attributes from cool TV shows -->\n\n<!-- shows <- list( -->\n<!--   avatar = tibble(                                                       # Dataframe 1 -->\n<!--     name = c(\"Katara\", \"Aang\", \"Sokka\", \"Toph\", \"Zuko\"), -->\n<!--     home = c( -->\n<!--       \"Southern Water Tribe\", \"Southern Air Temple\", -->\n<!--       \"Southern Water Tribe\", \"Earth Kingdom\", \"Fire Nation\" -->\n<!--     ), -->\n<!--     age = c(14, 112, 15, 12, 16), -->\n<!--     element = c(\"water\", \"air\", \"boomerang\", \"earth\", \"fire\") -->\n<!--   ), -->\n<!--   she_ra = tibble(                                                       # Dataframe 2 -->\n<!--     name = c(\"Adora\", \"Glimmer\", \"Bow\", \"Catra\", \"Scorpia\"), -->\n<!--     affiliation = c( -->\n<!--       \"Princess Alliance\", \"Princess Alliance\", -->\n<!--       \"Princess Alliance\", \"Horde\", \"Horde\" -->\n<!--     ), -->\n<!--     species = c( -->\n<!--       \"First One\", \"Etherian\", \"Etherian\", -->\n<!--       \"feline humanoid\", \"Scorpioni\" -->\n<!--     ) -->\n<!--   ), -->\n<!--   lower_decks = tibble(                                                  # Dataframe 3 -->\n<!--     name = c(\"Mariner\", \"Boimler\", \"Tendi\", \"Rutherford\"), -->\n<!--     division = c(\"command\", \"command\", \"science\", \"engineering\"), -->\n<!--     rank = c( -->\n<!--       \"lieutenant junior grade\", \"lieutenant junior grade\", -->\n<!--       \"lieutenant junior grade\", \"lieutenant junior grade\" -->\n<!--     ) -->\n<!--   ) -->\n<!-- ) -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- # A list of dataframes from the same shows but with some new characters -->\n\n<!-- shows2 <- list( -->\n<!--   avatar = tibble(                                                       # Dataframe 1 -->\n<!--     name = c(\"Zuko\", \"Azula\", \"Iroh\"), -->\n<!--     home = c(\"Fire Nation\", \"Fire Nation\", \"Fire Nation\"), -->\n<!--     age = c(16, 14, 66), -->\n<!--     element = c(\"fire\", \"fire\", \"fire\") -->\n<!--   ), -->\n<!--   she_ra = tibble(                                                       # Dataframe 2 -->\n<!--     name = c(\"Hordak\", \"Catra\", \"Scorpia\"), -->\n<!--     affiliation = c(\"Horde\", \"Horde\", \"Horde\"), -->\n<!--     species = c(\"clone\", \"feline humanoid\", \"Scorpioni\") -->\n<!--   ), -->\n<!--   lower_decks = tibble(                                                  # Dataframe 3 -->\n<!--     name = c(\"Mariner\", \"Boimler\"), -->\n<!--     division = c(\"command\", \"command\"), -->\n<!--     rank = c(\"lieutenant junior grade\", \"lieutenant junior grade\") -->\n<!--   ) -->\n<!-- ) -->\n<!-- ``` -->\n\n<!-- ## `map2()`: two lists as input, list output -->\n\n<!-- ***Example:*** Subset each dataframe in a list. -->\n\n<!-- `anti_join()` (dplyr) returns the rows in `x` that are not in `y`. -->\n\n<!-- . . . -->\n<!-- ```{r} -->\n<!-- shows_new <- map2(shows2, shows, anti_join, by = colnames(x)) -->\n\n<!-- str(shows_new) -->\n<!-- ``` -->\n\n## Summary\n\nRecommendations for when to use a given method:\n\n* `mutate()` is great for creating new columns or for modifying existing columns of a dataframe\n* `apply()` is great when the input is a dataframe row and you want a column, vector, or list as output\n* `lapply()` and `map()` are great for vector or list input and list output\n* Other `map()` functions are great for multiple vector or list inputs\n\n. . .\n\n**Caveat**: My recs are just to get you started. You'll find your own best use cases!\n\n## List wrangling\n\n::: {.nonincremental}\n* `unlist()`: converts a list into a vector\n* `append()`: adds elements to a list\n* `compact()`: drops null elements from a list\n* `list_rbind()`: flattens a list of dataframe rows into a single dataframe\n:::\n\nSee more on the purrr cheatsheet.\n\n## Workflow\n\n* When in doubt, start with a loop.\n* If the operation you want to iterate or vectorize has multiple steps, write a custom function.\n* If you decide to use something other than a loop, consider what you need as your input(s) and the shape you need your output to be.\n* In general, write code so that it's as easy as possible to troubleshoot.\n    + Make it easy to see object values in your environment\n    + Print to the console as a way of checking values\n    + Use RStudio's debugging tools (breakpoints, `debugonce()`, `browser()`)\n\n## Resources\n\n::: {.nonincremental}\n- [RUG SharePoint site (presentations on loops, custom functions)](https://sokansas.sharepoint.com/sites/KDHEBEPHI_RUsers)\n- [R for Data Science: Iteration](https://r4ds.hadley.nz/iteration.html)\n- [The Epidemiologist R Handbook: Iteration, loops, and lists](https://www.epirhandbook.com/en/new_pages/iteration.html)\n- [`mutate()` documentation](https://dplyr.tidyverse.org/reference/mutate.html)\n- [`across()` documentation](https://dplyr.tidyverse.org/reference/across.html)\n- [Tidy selection in dplyr functions](https://dplyr.tidyverse.org/reference/dplyr_tidy_select.html)\n- [purrr package & cheatsheet](https://purrr.tidyverse.org/index.html)\n- [DataCamp `apply()` tutorial](https://www.datacamp.com/tutorial/r-tutorial-apply-family)\n- [More help with `apply()`](https://ademos.people.uic.edu/Chapter4.html)\n:::\n","srcMarkdownNoYaml":"\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(\n  echo = TRUE,\n  R.options = list(width = 120)\n)\n```\n\n```{r include=FALSE}\nsource(\"fn.R\")\n```\n\n## Vectorization and iteration\n\nWhat does it mean?\n\n- Iteration: performing the same operation/function(s) multiple times\n- Vectorization: function input is a vector, function output is a vector\n\n## Outline\n\n- Vector basics\n- Methods to vectorize your code\n    + loops, `dplyr::mutate()`, `apply()` & friends, `purrr::map()` & friends\n- Useful workflows for introducing vectorization\n\n# Vector basics\n\n## What is a vector?\n\n- A data structure (container) with one dimension\n- Property = length\n- Types\n    + Atomic vector (one data type)\n    + List (multiple data types)\n\n## Vector types\n\n::::: {#row1}\n:::: {.columns}\n::: {.column .nonincremental width=\"50%\"}\n\nAtomic vector\n\n* elements are the same data type\n\n:::\n::: {.column width=\"50%\"}\n\n![numeric vector](images/numeric-vector.png)\n\n![character vector](images/character-vector.png)\n\n:::\n::::\n:::::\n\n::::: {#row2}\n:::: {.columns}\n::: {.column .nonincremental width=\"50%\"}\n\nList\n\n* elements can be different data types and data structures\n\n:::\n::: {.column width=\"50%\"}\n\n![](images/list.png)\n\n:::\n::::\n:::::\n\n## Atomic vectors\n\n`c()` creates atomic vectors.\n\n```{r}\nx <- c(\"a\", \"b\", \"c\", \"apple\", \"banana\", \"coconut\")    # character vector\ny <- c(10, 100, 1000, 10000, 100000)                   # numeric vector\nz <- c(TRUE, TRUE, FALSE, FALSE)                       # logical vector\n```\n\n```{r}\nclass(x)\nclass(y)\nclass(z)\n```\n\n## Lists\n\n`list()` creates lists.\n\n```{r}\nx <- c(\"a\", \"b\", \"c\", \"apple\", \"banana\", \"coconut\")    # character vector\ny <- c(10, 100, 1000, 10000, 100000)                   # numeric vector\nz <- c(TRUE, TRUE, FALSE, FALSE)                       # logical vector\n\nmy_list <- list(\n  element1 = x,\n  element2 = y,\n  element3 = z\n)\n```\n\n```{r}\nstr(my_list)\n```\n\n## Um actually\n\n*Technically...*\n\n:::{.nonincremental}\n* \"vector\" includes both atomic vectors and lists\n* dataframe columns are atomic vectors\n:::\n\n. . .\n\n*But colloquially...*\n\n:::{.nonincremental}\n* \"vector\" means an atomic vector\n* \"list\" means a list\n:::\n\n# Indexing: How to access elements of vectors\n\n## Indexing vectors\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\n. . .\n\nUse square brackets `[]` to access specific elements of atomic vectors by their numeric position.\n\n. . .\n\n```{r}\nelements[3]\n```\n\n. . .\n\n```{r}\nelements[1:3]\n```\n\n## Assign & subtract\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\n. . .\n\nAssignment by indexing\n\n```{r}\nelements[5] <- \"cheese\"\n\nelements\n```\n\n. . .\n\nSubtraction by indexing\n\n```{r}\nelements <- elements[-5]\n\nelements\n```\n\n## Numeric vs logical indexing\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\nVectors are indexed with other vectors.\n\n. . .\n\n```{r}\nelements[c(1, 4)]               # numeric vector\n```\n\n. . .\n\n```{r}\nelements[c(T, F, F, T)]         # logical vector\n```\n\n## Numeric vs logical indexing\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\nIf the indexing vector isn't the same length as the vector being indexed, the indexing vector will be recycled.\n\n. . .\n\n```{r}\nelements[c(T, F)]\n```\n\n```{r}\nelements[c(T, F, F)]\n```\n\n## Index with expressions\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\nIf the value of an expression is a numeric or logical vector, it can be used to index.\n\n. . .\n\n```{r}\n2 + 2                  # numeric expression\nelements[2 + 2]\n```\n\n## Index with expressions\n\n```{r}\nelements <- c(\"water\", \"earth\", \"fire\", \"air\")\n```\n\nIf the value of an expression is a numeric or logical vector, it can be used to index.\n\n```{r}\nstringr::str_detect(elements, \"^e|e$\")                  # logical expression\nelements[stringr::str_detect(elements, \"^e|e$\")]\n```\n\n## Indexing lists\n\n:::: {.columns}\n::: {.column}\n\nSingle square brackets `[]`\n\n```{r}\nmy_list[1]\nclass(my_list[1])\n```\n\n:::\n::: {.column}\n\nDouble square brackets `[[]]`\n\n```{r}\nmy_list[[1]]\nclass(my_list[[1]])\n```\n\n:::\n::::\n\n## Indexing lists\n\nAccess list elements by name using `$` (equivalent to `[[]]`).\n\n:::: {.columns}\n::: {.column}\n\n```{r}\nmy_list$element1\nclass(my_list$element1)\n```\n\n:::\n::: {.column}\n\n```{r}\nmy_list[[\"element1\"]]\nclass(my_list[[\"element1\"]])\n```\n\n:::\n::::\n\n# Methods: Using vectorization and iteration in your code\n\n## Methods\n\n::: {.nonincremental}\n- Loops\n- `dplyr::mutate()`\n- `apply()` & friends\n- `purrr::map()` & friends\n:::\n\n## Loops\n\n::: {.nonincremental}\n- for & while\n- extremely useful and versatile\n- covered in a prior RUG workshop\n- loops will return when we talk about workflow\n:::\n\n## `dplyr::mutate()`\n\n::: {.nonincremental}\n- iterate over all rows of a dataframe by apply a function to a column or columns\n- create new columns or modify existing columns\n:::\n\n[`mutate()` documentation](https://dplyr.tidyverse.org/reference/mutate.html#ref-usage){preview-link=\"true\"}\n\n## Syntax\n\n```{r eval=FALSE}\ndata <- data |>\n  mutate(column_name = some_function(existing_column))      # dummy syntax\n```\n\n## `mutate()`: create a new column\n\nCalculate age from two dates.\n\n```{r}\nlibrary(tidyverse)\nlibrary(ksTracking)\n\ndate1 <- as.Date(\"1980-08-01\")\ndate2 <- as.Date(Sys.Date())\n\ncalculate_age(date1, date2)         # the function by itself\n```\n\n## `mutate()`: create a new column\n\n::: {.panel-tabset}\n\n### Dataframe\n\nSimulate a data set with two date variables: `birth_date` and `collection_date`.\n\n```{r}\nbl_data <- sim_bl_data(n_tested = 10, test_range = c(\"2024-01-01\", \"2024-03-31\"))\n```\n\n```{r}\n#| code-fold: true\n\nbl_data |>\n  my_gt() |>\n  gtExtras::gt_highlight_cols(\n    columns = c(birth_date, collection_date),\n    fill = \"thistle2\"\n  )\n```\n\n### `mutate()`\n\n```{r eval=FALSE}\ndata <- data |>\n  mutate(column_name = some_function(existing_column))      # dummy syntax\n```\n\n```{r}\nbl_data2 <- bl_data |>\n  mutate(                                                   # for real\n    age = calculate_age(birth_date, collection_date),\n    .after = collection_date\n  )\n```\n\n```{r}\n#| code-fold: true\n\nbl_data2 |>\n  my_gt() |>\n  gtExtras::gt_highlight_cols(\n    columns = c(birth_date, collection_date),\n    fill = \"thistle2\"\n  ) |>\n  gtExtras::gt_highlight_cols(\n    columns = c(age),\n    fill = \"palegreen\"\n  )\n```\n\n:::\n\n## `mutate()` + `across()`\n\n`across()` applies the `mutate()` call to multiple columns at once.\n\n::: {.panel-tabset}\n\n### Select columns\n\n```{r}\nbl_data |>\n  select(starts_with(\"coll_add\")) |>      # tidy selection\n  my_gt()\n```\n\n### `mutate()`\n\n```{r}\nbl_data3 <- bl_data |>\n  mutate(across(starts_with(\"coll_add\"), toupper))   # convert to uppercase\n```\n\n```{r}\n#| code-fold: true\n\nbl_data3 |>\n  select(starts_with(\"coll_add\")) |>\n  my_gt()\n```\n\n:::\n\n## `apply()` & friends\n\n::: {.nonincremental}\n- `apply()`: modify rows or columns of a dataframe\n- `lapply()`: modify a vector or list\n- also `sapply()`, `vapply()`, & `mapply()`\n:::\n\n## `lapply()`\n\nIterate over a vector or list\n\n::: {.nonincremental}\n- Input: a vector or list\n- Output: a vector or list\n- Arguments:\n    + `X`: a vector or list\n    + `FUN`: a function\n    + `...`: additional arguments to `FUN` (optional)\n:::\n\n## `lapply()`\n\n::: {.panel-tabset}\n\n### List\n\n```{r}\nl <- list()\n\nfor (i in 1:5) {                             # populate a list\n  l[[i]] <- c(                               # each element contains:\n    sample(colors(), 1),                     #  - a color\n    sample(rownames(alr4::brains), 1),       #  - an animal\n    sample(rownames(alr4::BigMac2003), 1)    #  - a city\n  )\n}\n\nl\n```\n\n### `lapply()`\n\n```{r}\nl2 <- lapply(\n  X = l,               # list input\n  FUN = paste,         # function: `paste()`\n  collapse = \"; \"      # additional argument to `paste()`\n)\n\nl2\n```\n\n:::\n\n## `lapply()` + custom function\n\n::: {.panel-tabset}\n\n### List\n\n```{r}\nl <- list(                  # create a list of 3 dataframes\n  df1 = mtcars,\n  df2 = dplyr::starwars,\n  df3 = bl_data\n)\n```\n\n```{r results='asis'}\n#| code-fold: true\n\nfor (i in 1:length(l)) {    # print a section of each table\n  l[[i]][1:3, 1:11] |>\n    my_gt() |>\n    print()\n}\n```\n\n### Function\n\n```{r}\n# custom function to\n#   1) modify column names \n#   2) add a column\n\nfn <- function(df) {\n  colnames(df) <- stringr::str_to_title(colnames(df))\n  df |>\n    mutate(Action = NA, .before = everything())\n}\n```\n\n### `lapply()`\n\n```{r}\nl2 <- lapply(\n  X = l,               # list input\n  FUN = fn             # function: `fn()`\n)\n```\n\n```{r results='asis'}\n#| code-fold: true\n\nfor (i in 1:length(l2)) {    # print a section of each table\n  l2[[i]][1:3, 1:12] |>\n    my_gt() |>\n    print()\n}\n```\n\n:::\n\n## `apply()`\n\nIterate over a dataframe's rows, columns, or both\n\n::: {.nonincremental}\n- Input: a dataframe\n- Output: a vector or list\n- Arguments:\n    + `X`: a dataframe\n    + `MARGIN`: `1` for rows, `2` for columns (`c(1, 2)` for both)\n    + `FUN`: a function\n    + `...`: additional arguments to `FUN` (optional)\n:::\n\n## `apply()`\n\n::: {.panel-tabset}\n\n### Dataframe\n\n```{r}\n#| output-location: column\n\n# create a dataframe from a list\n\nl <- list()\n\nfor (i in 1:5) {\n  l[[i]] <- sample(1:100, 10, T)\n}\n\ndf <- as_tibble(do.call(cbind, l))\n\ndf\n```\n\n### Rows\n\n```{r}\nrow_sums <- apply(\n  X = df,               # dataframe input\n  MARGIN = 1,           # apply over rows\n  FUN = sum             # function: `sum()`\n)\n\nrow_sums\n```\n\n### Columns\n\n```{r}\ncol_sums <- apply(\n  X = df,               # dataframe input\n  MARGIN = 2,           # apply over columns\n  FUN = sum             # function: `sum()`\n)\n\ncol_sums\n```\n\n:::\n\n## `apply()` vs `mutate()`\n\n::: {.nonincremental}\n- `mutate()`: applies a function to each row separately\n- `apply()`: applies a function to each row or each column as a whole\n:::\n\n## `apply()` + custom function\n\n::: {.panel-tabset}\n\n### Original fn\n\nCheck if a sequence of dates is in chronological order.\n\n```{r}\ncheck_date_seq            # from ksTracking package\n```\n\n### fn within the fn\n\n```{r}\nfn <- function(dates) {\n  # Convert a vector of dates to the underlying numeric values, removing NAs\n  seq <- stats::na.omit(as.numeric(as.Date(dates)))\n\n  # Compare the current order of `seq` to the sorted order (small to large)\n  all(seq == sort(seq))\n}\n```\n\n### Example\n\n```{r}\ndates1 <- c(\"1800-01-01\", \"1900-01-01\", \"2000-01-01\")   # in chronological order\n\nfn(dates1)\n\ndates2 <- c(\"2000-01-01\", \"1900-01-01\", \"1800-01-01\")   # not in chronological order\n\nfn(dates2)\n```\n\n:::\n\n## `apply()` + custom function\n\n::: {.panel-tabset}\n\n### Dataframe\n\n```{r}\n#| output-location: column\n\ndf <- tibble(\n  birth_date = sample(\n    seq.Date(\n      from = as.Date(\"1930-01-01\"),\n      to = as.Date(\"2020-12-31\"),\n      by = \"day\"\n    ),\n    size = 10,\n    replace = T\n  ),\n  test_date1 = sample(\n    seq.Date(\n      from = as.Date(\"2022-01-01\"),\n      to = as.Date(\"2023-12-21\"),\n      by = \"day\"\n    ),\n    size = 10,\n    replace = T\n  ),\n  test_date2 = sample(\n    seq.Date(\n      from = as.Date(\"2022-01-01\"),\n      to = as.Date(\"2023-12-21\"),\n      by = \"day\"\n    ),\n    size = 10,\n    replace = T\n  ),\n  city = sample(\n    ks_city_zip$city,\n    size = 10,\n    replace = T\n  ),\n  state = \"KS\"\n)\n\ndf |> my_gt()\n```\n\n### `apply()`\n\n```{r}\ndf$correct_date_seq <- apply(\n  X = df[, 1:3],                   # note partial dataframe input\n  MARGIN = 1,                      # apply over rows\n  FUN = fn                         # function: `fn()'\n)\n\ndf |> my_gt()\n```\n\n### Bonus\n\nPackage the date function and `apply()` together\n\n```{r}\nfn2 <- function(...) {      # `fn2()` is vectorized: it takes vectors as args,\n  df <- cbind(...)          # and outputs a vector of the same length\n\n  fn1 <- function(dates) {\n    seq <- stats::na.omit(as.numeric(as.Date(dates)))\n    all(seq == sort(seq))\n  }\n\n  apply(df, 1, fn)\n}\n\ndf$correct_date_seq2 <- fn2(df$birth_date, df$test_date1, df$test_date2)\n\ndf |> my_gt()\n```\n\n:::\n\n## `purrr::map()`\n\n:::::: {.panel-tabset}\n\n### Specs\n\n::::: {.columns}\n:::: {.column .nonincremental width=\"50%\"}\n::: {.nonincremental}\n\n`lapply()`\n\n- Input: a vector or list\n- Output: a vector or list\n- Arguments:\n    + `X`: a vector or list\n    + `FUN`: a function\n    + `...`: additional arguments to `FUN` (optional)\n\n:::\n::::\n\n:::: {.column .nonincremental width=\"50%\"}\n::: {.nonincremental}\n\n`map()`\n\n- Input: a vector or list\n- Output: a vector or list\n- Arguments:\n    + `.x`: a vector or list\n    + `.f`: a function\n    + `...`: additional arguments to `.f` (optional)\n\n:::\n::::\n:::::\n\n### List\n\n```{r}\nl <- list()\n\nfor (i in 1:5) {                             # populate a list\n  l[[i]] <- c(                               # each element contains:\n    sample(colors(), 1),                     #  - a color\n    sample(rownames(alr4::brains), 1),       #  - an animal\n    sample(rownames(alr4::BigMac2003), 1)    #  - a city\n  )\n}\n\nl\n```\n\n### Compare use\n\n::::: {.columns}\n:::: {.column .nonincremental width=\"50%\"}\n\n```{r}\nl2 <- lapply(\n  X = l,\n  FUN = paste,\n  collapse = \"; \"\n)\n\nl2\n```\n\n::::\n:::: {.column .nonincremental width=\"50%\"}\n\n```{r}\nl3 <- map(\n  .x = l,\n  .f = paste,\n  collapse = \"; \"\n)\n\nl3\n```\n\n::::\n:::::\n::::::\n\n## `map()` & friends\n\n\n\n\n```{r}\n\n```\n\n\n\n\n\n\n\n\n<!-- ## `lapply()` basics -->\n\n<!-- Input: a vector or list. Output: a vector or list. -->\n\n<!-- ::: {.sublist .nonincremental} -->\n<!-- `lapply()` arguments: -->\n\n<!-- - `X`: a vector or list -->\n<!-- - `FUN`: a function -->\n<!-- - `...`: additional (optional) arguments to `FUN` -->\n<!-- ::: -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- ***Example:*** Convert a nested list to a dataframe. -->\n\n<!-- Create a nested list. -->\n\n<!-- ```{r} -->\n<!-- name <- c(\"Katara\", \"Aang\", \"Sokka\", \"Toph\", \"Zuko\") -->\n<!-- home <- c( -->\n<!--   \"Southern Water Tribe\", \"Southern Air Temple\", -->\n<!--   \"Southern Water Tribe\", \"Earth Kingdom\", \"Fire Nation\" -->\n<!-- ) -->\n<!-- age <- c(14, 112, 15, 12, 16) -->\n<!-- element <- c(\"water\", \"air\", NA, \"earth\", \"fire\") -->\n\n<!-- avatar_list <- list() -->\n\n<!-- for (i in 1:length(name)) { -->\n<!--   avatar_list[[i]] <- list( -->\n<!--     name = name[i], home = home[i], age = age[i], element = element[i] -->\n<!--   ) -->\n<!-- } -->\n<!-- ``` -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- ***Example:*** Convert a nested list to a dataframe. -->\n\n<!-- ```{r} -->\n<!-- str(avatar_list) -->\n<!-- ``` -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- ***Example:*** Convert a nested list to a dataframe. -->\n\n<!-- Use `lapply()` to call `as_tibble()`, turning each list element into a one-row dataframe. -->\n\n<!-- ```{r} -->\n<!-- avatar_list2 <- lapply(X = avatar_list, FUN = as_tibble) -->\n<!-- ``` -->\n\n<!-- . . . -->\n\n<!-- :::: {.columns} -->\n<!-- ::: {.column width=\"50%\"} -->\n<!-- ```{r} -->\n<!-- # Input -->\n<!-- str(avatar_list) -->\n<!-- ``` -->\n<!-- ::: -->\n<!-- ::: {.column width=\"50%\"} -->\n<!-- ```{r} -->\n<!-- # Output -->\n<!-- str(avatar_list2) -->\n<!-- ``` -->\n<!-- ::: -->\n<!-- :::: -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- ***Example:*** Convert a nested list to a dataframe. -->\n\n<!-- The new list can now be converted to a dataframe using `purrr::list_rbind()`. -->\n\n<!-- ```{r} -->\n<!-- avatar_df <- list_rbind(avatar_list2) -->\n<!-- ``` -->\n<!-- . . . -->\n<!-- ```{r} -->\n<!-- head(avatar_df) %>% gfx_kable() -->\n<!-- ``` -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- ***Example:*** Convert a nested list to a dataframe. -->\n\n<!-- The whole thing: -->\n\n<!-- ```{r} -->\n<!-- avatar_list2 <- lapply(X = avatar_list, FUN = as_tibble) -->\n\n<!-- avatar_df <- list_rbind(avatar_list2) -->\n<!-- ``` -->\n\n<!-- ## `lapply()`: list input, list output -->\n\n<!-- Using `...` to pass additional arguments to `FUN`: -->\n\n<!-- ```{r} -->\n<!-- avatar_list2 <- lapply( -->\n<!--   X = avatar_list, FUN = as_tibble, -->\n<!--   .name_repair = function(x) paste0(x, \"_season_1\")    # New argument, modifies column names -->\n<!-- ) -->\n\n<!-- avatar_df <- list_rbind(avatar_list2) -->\n<!-- ``` -->\n<!-- . . . -->\n<!-- ```{r} -->\n<!-- head(avatar_df) %>% gfx_kable() -->\n<!-- ``` -->\n\n<!-- ## `map()` -->\n\n<!-- `map()` (purrr) is essentially the same as `lapply()`. -->\n\n<!-- ```{r} -->\n<!-- avatar_list2 <- lapply(X = avatar_list, FUN = as_tibble) -->\n\n<!-- avatar_list3 <- map(.x = avatar_list, .f = as_tibble) -->\n\n<!-- all.equal(avatar_list2, avatar_list3) -->\n<!-- ``` -->\n\n<!-- . . . -->\n\n<!-- ::: {.sublist} -->\n<!-- Variations for different types of input and output, for example: -->\n\n<!-- - `map2()`: two inputs (`.x` & `.y`), e.g., two vectors or lists of the same length -->\n<!-- - `pmap()`: input is a list (`.l`), each element of which is a vector passed as an argument to `.f` -->\n<!-- ::: -->\n\n<!-- ## `map2()`: two lists as input, list output {.scrollable} -->\n\n<!-- ***Example:*** Subset each dataframe in a list. -->\n\n<!-- ```{r} -->\n<!-- # A list of dataframes with characters and attributes from cool TV shows -->\n\n<!-- shows <- list( -->\n<!--   avatar = tibble(                                                       # Dataframe 1 -->\n<!--     name = c(\"Katara\", \"Aang\", \"Sokka\", \"Toph\", \"Zuko\"), -->\n<!--     home = c( -->\n<!--       \"Southern Water Tribe\", \"Southern Air Temple\", -->\n<!--       \"Southern Water Tribe\", \"Earth Kingdom\", \"Fire Nation\" -->\n<!--     ), -->\n<!--     age = c(14, 112, 15, 12, 16), -->\n<!--     element = c(\"water\", \"air\", \"boomerang\", \"earth\", \"fire\") -->\n<!--   ), -->\n<!--   she_ra = tibble(                                                       # Dataframe 2 -->\n<!--     name = c(\"Adora\", \"Glimmer\", \"Bow\", \"Catra\", \"Scorpia\"), -->\n<!--     affiliation = c( -->\n<!--       \"Princess Alliance\", \"Princess Alliance\", -->\n<!--       \"Princess Alliance\", \"Horde\", \"Horde\" -->\n<!--     ), -->\n<!--     species = c( -->\n<!--       \"First One\", \"Etherian\", \"Etherian\", -->\n<!--       \"feline humanoid\", \"Scorpioni\" -->\n<!--     ) -->\n<!--   ), -->\n<!--   lower_decks = tibble(                                                  # Dataframe 3 -->\n<!--     name = c(\"Mariner\", \"Boimler\", \"Tendi\", \"Rutherford\"), -->\n<!--     division = c(\"command\", \"command\", \"science\", \"engineering\"), -->\n<!--     rank = c( -->\n<!--       \"lieutenant junior grade\", \"lieutenant junior grade\", -->\n<!--       \"lieutenant junior grade\", \"lieutenant junior grade\" -->\n<!--     ) -->\n<!--   ) -->\n<!-- ) -->\n<!-- ``` -->\n\n<!-- ```{r} -->\n<!-- # A list of dataframes from the same shows but with some new characters -->\n\n<!-- shows2 <- list( -->\n<!--   avatar = tibble(                                                       # Dataframe 1 -->\n<!--     name = c(\"Zuko\", \"Azula\", \"Iroh\"), -->\n<!--     home = c(\"Fire Nation\", \"Fire Nation\", \"Fire Nation\"), -->\n<!--     age = c(16, 14, 66), -->\n<!--     element = c(\"fire\", \"fire\", \"fire\") -->\n<!--   ), -->\n<!--   she_ra = tibble(                                                       # Dataframe 2 -->\n<!--     name = c(\"Hordak\", \"Catra\", \"Scorpia\"), -->\n<!--     affiliation = c(\"Horde\", \"Horde\", \"Horde\"), -->\n<!--     species = c(\"clone\", \"feline humanoid\", \"Scorpioni\") -->\n<!--   ), -->\n<!--   lower_decks = tibble(                                                  # Dataframe 3 -->\n<!--     name = c(\"Mariner\", \"Boimler\"), -->\n<!--     division = c(\"command\", \"command\"), -->\n<!--     rank = c(\"lieutenant junior grade\", \"lieutenant junior grade\") -->\n<!--   ) -->\n<!-- ) -->\n<!-- ``` -->\n\n<!-- ## `map2()`: two lists as input, list output -->\n\n<!-- ***Example:*** Subset each dataframe in a list. -->\n\n<!-- `anti_join()` (dplyr) returns the rows in `x` that are not in `y`. -->\n\n<!-- . . . -->\n<!-- ```{r} -->\n<!-- shows_new <- map2(shows2, shows, anti_join, by = colnames(x)) -->\n\n<!-- str(shows_new) -->\n<!-- ``` -->\n\n## Summary\n\nRecommendations for when to use a given method:\n\n* `mutate()` is great for creating new columns or for modifying existing columns of a dataframe\n* `apply()` is great when the input is a dataframe row and you want a column, vector, or list as output\n* `lapply()` and `map()` are great for vector or list input and list output\n* Other `map()` functions are great for multiple vector or list inputs\n\n. . .\n\n**Caveat**: My recs are just to get you started. You'll find your own best use cases!\n\n## List wrangling\n\n::: {.nonincremental}\n* `unlist()`: converts a list into a vector\n* `append()`: adds elements to a list\n* `compact()`: drops null elements from a list\n* `list_rbind()`: flattens a list of dataframe rows into a single dataframe\n:::\n\nSee more on the purrr cheatsheet.\n\n## Workflow\n\n* When in doubt, start with a loop.\n* If the operation you want to iterate or vectorize has multiple steps, write a custom function.\n* If you decide to use something other than a loop, consider what you need as your input(s) and the shape you need your output to be.\n* In general, write code so that it's as easy as possible to troubleshoot.\n    + Make it easy to see object values in your environment\n    + Print to the console as a way of checking values\n    + Use RStudio's debugging tools (breakpoints, `debugonce()`, `browser()`)\n\n## Resources\n\n::: {.nonincremental}\n- [RUG SharePoint site (presentations on loops, custom functions)](https://sokansas.sharepoint.com/sites/KDHEBEPHI_RUsers)\n- [R for Data Science: Iteration](https://r4ds.hadley.nz/iteration.html)\n- [The Epidemiologist R Handbook: Iteration, loops, and lists](https://www.epirhandbook.com/en/new_pages/iteration.html)\n- [`mutate()` documentation](https://dplyr.tidyverse.org/reference/mutate.html)\n- [`across()` documentation](https://dplyr.tidyverse.org/reference/across.html)\n- [Tidy selection in dplyr functions](https://dplyr.tidyverse.org/reference/dplyr_tidy_select.html)\n- [purrr package & cheatsheet](https://purrr.tidyverse.org/index.html)\n- [DataCamp `apply()` tutorial](https://www.datacamp.com/tutorial/r-tutorial-apply-family)\n- [More help with `apply()`](https://ademos.people.uic.edu/Chapter4.html)\n:::\n"},"formats":{"revealjs":{"identifier":{"display-name":"RevealJS","target-format":"revealjs","base-format":"revealjs"},"execute":{"fig-width":10,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":false,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"wrap","code-link":false,"code-line-numbers":true,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","html-math-method":{"method":"mathjax","url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML-full"},"slide-level":2,"to":"revealjs","highlight-style":"github","css":["styles.css"],"incremental":true,"output-file":"slides.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":false,"quarto-version":"1.5.55","auto-stretch":true,"title":"Vectorization and iteration in R","author":"Eliot Monaco","date":"4/8/2024","theme":"dark","width":1300,"slideNumber":true,"previewLinks":true,"scrollable":true,"chalkboard":{"buttons":false}}}},"projectFormats":[]}